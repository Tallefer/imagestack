#ifndef IMAGESTACK_COMPILER_H
#define IMAGESTACK_COMPILER_H

#include <vector>
#include "Parser.h"

#include "header.h"

const char *opname[] = {"Const", "VarX", "VarY", "VarT", "VarC", "VarVal", "Negate", "Plus", "Minus", 
                        "Times", "Divide", "LT", "GT", "LTE", "GTE", "EQ", "NEQ", "Sin", "Cos", "Tan", "Pow",
                        "ASin", "ACos", "ATan", "ATan2", "Abs", "Floor", "Ceil", "Round",
                        "Exp", "Log", "Mod", "SampleHere", "Sample2D", "Sample3D", "IfThenElse"};


// A compiler for parsed expressions
class Program : public Expression::Visitor {
private:
    // bytecode instructions
    struct ByteCode {
        enum Op {Const = 0, VarX, VarY, VarT, VarC, VarVal, Negate, Plus, Minus, 
                 Times, Divide, LT, GT, LTE, GTE, EQ, NEQ, Sin, Cos, Tan, Pow,
                 ASin, ACos, ATan, ATan2, Abs, Floor, Ceil, Round,
                 Exp, Log, Mod, SampleHere, Sample2D, Sample3D, IfThenElse};
        Op op;
        float val; // for const only
    };

    // these are used at runtime
    vector<float> stack;
    float *ptr;
    vector<float> sample;

    std::vector<ByteCode> instructions;
    Window im;
    Stats stats;

public:

    struct State {
        int x, y, t, c;
        float *val;
    };

    Program(const Expression &e, Window w) : im(w), stats(w) {
        // traverse the tree and generate bytecode
        e.root->accept(this);

        // compute the max stack depth needed
        int stackSize = 0;
        int maxStackSize = 0;
        for (size_t i = 0; i < instructions.size(); i++) {
            switch(instructions[i].op) {
            case ByteCode::Const: case ByteCode::VarX: case ByteCode::VarVal:
            case ByteCode::VarY: case ByteCode::VarT: case ByteCode::VarC:
                stackSize++;
                break;
            case ByteCode::Plus: case ByteCode::Minus: case ByteCode::Times: 
            case ByteCode::Divide: case ByteCode::LT: case ByteCode::GT:
            case ByteCode::LTE: case ByteCode::GTE: case ByteCode::ATan2:
            case ByteCode::Sample2D: case ByteCode::Mod: case ByteCode::Pow:
            case ByteCode::EQ: case ByteCode::NEQ:
                stackSize--;
                break;
            case ByteCode::IfThenElse: case ByteCode::Sample3D:
                stackSize-=2;
                break;
            default:                
                break;
            }
            if (stackSize > maxStackSize) maxStackSize = stackSize;
        }

        stack.resize(maxStackSize);
        sample.resize(w.channels);

        
        printf("Compiled. Max stack size: %d\n", maxStackSize);
        for (size_t i = 0; i < instructions.size(); i++) {
            if (instructions[i].op) 
                printf("%s\n", opname[instructions[i].op]);
            else
                printf("%f\n", instructions[i].val);
        }
        
    } 

    void gen(ByteCode::Op op) {
        ByteCode inst;
        inst.op = op;
        instructions.push_back(inst);
    }

    void gen(float f) {
        ByteCode inst;
        inst.op = ByteCode::Const;
        inst.val = f;
        instructions.push_back(inst);
    }

    // optimizations
    void typeInference() {       
    }
    
    void strengthReduction() {
    }

    void commonSubExpressionElimination() {
    }

    void constantFolding() {
    }

    // interpret the generated bytecode
    float interpret(const State &s) {
        ptr = &(stack[0]);
        float tmp;
        for (size_t i = 0; i < instructions.size(); i++) {
            switch(instructions[i].op) {
            case ByteCode::Const: 
                *ptr++ = instructions[i].val;
                break;
            case ByteCode::VarX:
                *ptr++ = s.x;
                break;
            case ByteCode::VarY:
                *ptr++ = s.y;
                break;
            case ByteCode::VarT:
                *ptr++ = s.t;
                break;
            case ByteCode::VarC:
                *ptr++ = s.c;
                break;
            case ByteCode::VarVal:
                *ptr++ = s.val[s.c];
                break;
            case ByteCode::Plus:
                ptr[-2] += ptr[-1];
                ptr--;
                break;
            case ByteCode::Minus:
                ptr[-2] -= ptr[-1];
                ptr--;
                break;
            case ByteCode::Times: 
                ptr[-2] *= ptr[-1];
                ptr--;
                break;
            case ByteCode::Divide: 
                ptr[-2] /= ptr[-1];
                ptr--;
                break;
            case ByteCode::LT: 
                tmp = (ptr[-2] < ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::GT:
                tmp = (ptr[-2] > ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::LTE:
                tmp = (ptr[-2] <= ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::GTE:
                tmp = (ptr[-2] >= ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::EQ:
                tmp = (ptr[-2] == ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::NEQ:
                tmp = (ptr[-2] != ptr[-1]) ? 1 : 0;
                ptr[-2] = tmp;
                ptr--;
                break;
            case ByteCode::ATan2:
                ptr[-2] = atan2(ptr[-2], ptr[-1]);
                ptr--;
                break;
            case ByteCode::Sample2D: 
                im.sample2D(ptr[-2], ptr[-1], &(sample[0]));
                ptr[-2] = sample[s.c];
                ptr--;
                break;
            case ByteCode::Sample3D:
                im.sample2D(ptr[-3], ptr[-2], ptr[-1], &(sample[0]));
                ptr[-3] = sample[s.c];
                ptr -= 2;
                break;
            case ByteCode::IfThenElse:
                if (ptr[-3] > 0.5) ptr[-3] = ptr[-2];
                else ptr[-3] = ptr[-1];
                ptr -= 2;
                break;
            case ByteCode::SampleHere:
                tmp = roundf(ptr[-1]);
                ptr[-1] = s.val[(int)tmp];
                break;
            case ByteCode::Mod:
                ptr[-2] = fmod(ptr[-2], ptr[-1]);
                ptr--;
                break;
            case ByteCode::Pow:
                ptr[-2] = powf(ptr[-2], ptr[-1]);
                ptr--;
                break;
            case ByteCode::Sin:
                ptr[-1] = sinf(ptr[-1]);
                break;
            case ByteCode::Cos:
                ptr[-1] = cosf(ptr[-1]);
                break;
            case ByteCode::Tan:
                ptr[-1] = tanf(ptr[-1]);
                break;   
            case ByteCode::ASin:
                ptr[-1] = asinf(ptr[-1]);
                break;
            case ByteCode::ACos:
                ptr[-1] = acosf(ptr[-1]);
                break;
            case ByteCode::ATan:
                ptr[-1] = atanf(ptr[-1]);
                break;   
            case ByteCode::Exp:
                ptr[-1] = expf(ptr[-1]);
                break;
            case ByteCode::Log:
                ptr[-1] = logf(ptr[-1]);
                break;
            case ByteCode::Negate:
                ptr[-1] = -ptr[-1];
                break;
            case ByteCode::Floor:
                ptr[-1] = floorf(ptr[-1]);
                break;
            case ByteCode::Ceil:
                ptr[-1] = ceilf(ptr[-1]);
                break;
            case ByteCode::Round:
                ptr[-1] = roundf(ptr[-1]);
                break;
            case ByteCode::Abs:
                ptr[-1] = fabs(ptr[-1]);
                break;
            }
            /*
            printf("Stack %d: ", ptr-&(stack[0]));
            for (size_t j = 0; j < stack.size(); j++) {
                if (&(stack[j]) == ptr) break;
                printf("%f ", stack[j]);
            }
            printf("\n");
            */
        }        
        return stack[0];
    }
 
    void compile(AsmX64 *a, AsmX64::Reg x, AsmX64::Reg y,
                 AsmX64::Reg t, AsmX64::Reg c, AsmX64::Reg ptr) {

        int r = 0;
        for (size_t i = 0; i < instructions.size(); i++) {
            switch(instructions[i].op) {
            case ByteCode::Const: 
                a->movss(AsmX64::SSEReg(r++), &(instructions[i].val));
                break;
            case ByteCode::VarX:
            case ByteCode::VarY:
            case ByteCode::VarT:
            case ByteCode::VarC:
                printf("Not implemented\n");                
                break;
            case ByteCode::VarVal:
                a->movss(AsmX64::SSEReg(r++), AsmX64::Memory(ptr));
                break;
            case ByteCode::Plus:
                a->addss(AsmX64::SSEReg(r-2), AsmX64::SSEReg(r-1));
                r--;
                break;
            case ByteCode::Minus:
            case ByteCode::Times: 
            case ByteCode::Divide: 
            case ByteCode::LT: 
            case ByteCode::GT:
            case ByteCode::LTE:
            case ByteCode::GTE:
            case ByteCode::EQ:
            case ByteCode::NEQ:
            case ByteCode::ATan2:
            case ByteCode::Sample2D: 
            case ByteCode::Sample3D:
            case ByteCode::IfThenElse:
            case ByteCode::SampleHere:
            case ByteCode::Mod:
            case ByteCode::Pow:
            case ByteCode::Sin:
            case ByteCode::Cos:
            case ByteCode::Tan:
            case ByteCode::ASin:
            case ByteCode::ACos:
            case ByteCode::ATan:
            case ByteCode::Exp:
            case ByteCode::Log:
            case ByteCode::Negate:
            case ByteCode::Floor:
            case ByteCode::Ceil:
            case ByteCode::Round:
            case ByteCode::Abs:
                printf("Not implemented\n");                
                break;
            }
    }

    void visit(Expression::Var_x *node) {gen(ByteCode::VarX);}
    void visit(Expression::Var_y *node) {gen(ByteCode::VarY);}
    void visit(Expression::Var_t *node) {gen(ByteCode::VarT);}
    void visit(Expression::Var_c *node) {gen(ByteCode::VarC);}
    void visit(Expression::Var_val *node) {gen(ByteCode::VarVal);}
    void visit(Expression::Uniform_width *node) {gen(im.width);}
    void visit(Expression::Uniform_height *node) {gen(im.height);}
    void visit(Expression::Uniform_frames *node) {gen(im.frames);}
    void visit(Expression::Uniform_channels *node) {gen(im.channels);}
    void visit(Expression::Float *node) {gen(node->value);}
    
    void visit(Expression::Negation *node) {node->arg1->accept(this); gen(ByteCode::Negate);}
    void visit(Expression::Funct_sin *node) {node->arg1->accept(this); gen(ByteCode::Sin);}
    void visit(Expression::Funct_cos *node) {node->arg1->accept(this); gen(ByteCode::Cos);}
    void visit(Expression::Funct_tan *node) {node->arg1->accept(this); gen(ByteCode::Tan);}
    void visit(Expression::Funct_atan *node) {node->arg1->accept(this); gen(ByteCode::ATan);}
    void visit(Expression::Funct_asin *node) {node->arg1->accept(this); gen(ByteCode::ASin);}
    void visit(Expression::Funct_acos *node) {node->arg1->accept(this); gen(ByteCode::ACos);}
    void visit(Expression::Funct_abs *node) {node->arg1->accept(this); gen(ByteCode::Abs);}
    void visit(Expression::Funct_floor *node) {node->arg1->accept(this); gen(ByteCode::Floor);}
    void visit(Expression::Funct_ceil *node) {node->arg1->accept(this); gen(ByteCode::Ceil);}
    void visit(Expression::Funct_round *node) {node->arg1->accept(this); gen(ByteCode::Round);}
    void visit(Expression::Funct_log *node) {node->arg1->accept(this); gen(ByteCode::Log);}
    void visit(Expression::Funct_exp *node) {node->arg1->accept(this); gen(ByteCode::Exp);}
    void visit(Expression::Funct_mean0 *node) {gen(stats.mean());}
    void visit(Expression::Funct_sum0 *node) {gen(stats.sum());}
    void visit(Expression::Funct_max0 *node) {gen(stats.maximum());}
    void visit(Expression::Funct_min0 *node) {gen(stats.minimum());}
    void visit(Expression::Funct_variance0 *node) {gen(stats.variance());}
    void visit(Expression::Funct_stddev0 *node) {gen(sqrtf(stats.variance()));}
    void visit(Expression::Funct_skew0 *node) {gen(stats.skew());}
    void visit(Expression::Funct_kurtosis0 *node) {gen(stats.kurtosis());}    

    // TODO
    void visit(Expression::Funct_mean1 *node) {gen(0);}
    void visit(Expression::Funct_sum1 *node) {gen(0);}
    void visit(Expression::Funct_max1 *node) {gen(0);}
    void visit(Expression::Funct_min1 *node) {gen(0);}
    void visit(Expression::Funct_variance1 *node) {gen(0);}
    void visit(Expression::Funct_stddev1 *node) {gen(0);}
    void visit(Expression::Funct_skew1 *node) {gen(0);}
    void visit(Expression::Funct_kurtosis1 *node) {gen(0);}
    void visit(Expression::Funct_covariance *node) {gen(0);}
    
    void visit(Expression::LTE *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::LTE);
    }
    
    void visit(Expression::GTE *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::GTE);
    }
    
    void visit(Expression::LT *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::LT);
    }
    
    void visit(Expression::GT *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::GT);
    }
    
    void visit(Expression::EQ *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::EQ);
    }
    
    void visit(Expression::NEQ *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::NEQ);
    }
    
    void visit(Expression::Plus *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Plus);
    }
    
    void visit(Expression::Minus *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Minus);
    }
    
    void visit(Expression::Times *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Times);
    }
    
    void visit(Expression::Mod *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Mod);
    }
    
    void visit(Expression::Divide *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Divide);
    }
    
    void visit(Expression::Power *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::Pow);
    }
    
    void visit(Expression::Funct_atan2 *node) {
        node->arg1->accept(this); 
        node->arg2->accept(this);
        gen(ByteCode::ATan2);
    }
    
    void visit(Expression::IfThenElse *node) {
        node->arg1->accept(this);
        node->arg2->accept(this);
        node->arg3->accept(this);
        gen(ByteCode::IfThenElse);
    }
    
    void visit(Expression::SampleHere *node) {
        node->arg1->accept(this);
        gen(ByteCode::SampleHere);
    }
    
    void visit(Expression::Sample2D *node) {
        node->arg1->accept(this);
        node->arg2->accept(this);
        gen(ByteCode::Sample2D);
    }
    
    void visit(Expression::Sample3D *node) {
        node->arg1->accept(this);
        node->arg2->accept(this);
        node->arg3->accept(this);
        gen(ByteCode::Sample3D);
    }

};

#include "footer.h"
#endif
